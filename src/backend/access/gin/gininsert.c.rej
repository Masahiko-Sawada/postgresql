--- src/backend/access/gin/gininsert.c
+++ src/backend/access/gin/gininsert.c
@@ -42,14 +42,17 @@
  * items[] must be in sorted order with no duplicates.
  */
 static BlockNumber
-createPostingTree(Relation index, ItemPointerData *items, uint32 nitems)
+createPostingTree(GinState *ginstate, OffsetNumber attnum, Relation index,
+	ItemPointerData *items, Datum *addInfo, bool *addInfoIsNull, uint32 nitems)
 {
 	BlockNumber blkno;
 	Buffer		buffer = GinNewBuffer(index);
 	Page		page;
+	int			i;
+	Pointer		ptr;
+	ItemPointerData prev_iptr = {{0,0},0};
 
 	/* Assert that the items[] array will fit on one page */
-	Assert(nitems <= GinMaxLeafDataItems);
 
 	START_CRIT_SECTION();
 
@@ -57,8 +60,17 @@
 	page = BufferGetPage(buffer);
 	blkno = BufferGetBlockNumber(buffer);
 
-	memcpy(GinDataPageGetData(page), items, sizeof(ItemPointerData) * nitems);
 	GinPageGetOpaque(page)->maxoff = nitems;
+	ptr = GinDataPageGetData(page);
+	for (i = 0; i < nitems; i++)
+	{
+		if (i > 0)
+			prev_iptr = items[i - 1];
+		ptr = ginPlaceToDataPageLeaf(ptr, attnum, &items[i], addInfo[i],
+			addInfoIsNull[i], &prev_iptr, ginstate);
+	}
+	Assert(GinDataPageFreeSpacePre(page, ptr) >= 0);
+	updateItemIndexes(page, attnum, ginstate);
 
 	MarkBufferDirty(buffer);
 
@@ -72,14 +84,22 @@
 		data.blkno = blkno;
 		data.nitem = nitems;
 
+		if (ginstate->addAttrs[attnum - 1])
+		{
+			data.typlen = ginstate->addAttrs[attnum - 1]->attlen;
+			data.typalign = ginstate->addAttrs[attnum - 1]->attalign;
+			data.typbyval = ginstate->addAttrs[attnum - 1]->attbyval;
+			data.typstorage = ginstate->addAttrs[attnum - 1]->attstorage;
+		}
+
 		rdata[0].buffer = InvalidBuffer;
 		rdata[0].data = (char *) &data;
 		rdata[0].len = sizeof(ginxlogCreatePostingTree);
 		rdata[0].next = &rdata[1];
 
 		rdata[1].buffer = InvalidBuffer;
-		rdata[1].data = (char *) items;
-		rdata[1].len = sizeof(ItemPointerData) * nitems;
+		rdata[1].data = GinDataPageGetData(page);
+		rdata[1].len = GinDataPageSize - GinPageGetOpaque(page)->freespace;
 		rdata[1].next = NULL;
 
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_CREATE_PTREE, rdata);
@@ -243,38 +402,49 @@
 static IndexTuple
 addItemPointersToLeafTuple(GinState *ginstate,
 						   IndexTuple old,
-						   ItemPointerData *items, uint32 nitem,
+						   ItemPointerData *items, Datum *addInfo,
+						   bool *addInfoIsNull, uint32 nitem,
 						   GinStatsData *buildStats)
 {
 	OffsetNumber attnum;
 	Datum		key;
 	GinNullCategory category;
 	IndexTuple	res;
+	Datum		*oldAddInfo, *newAddInfo;
+	bool		*oldAddInfoIsNull, *newAddInfoIsNull;
+	ItemPointerData *newItems, *oldItems;
+	int			oldNPosting, newNPosting;
 
 	Assert(!GinIsPostingTree(old));
 
 	attnum = gintuple_get_attrnum(ginstate, old);
 	key = gintuple_get_key(ginstate, old, &category);
 
+	oldNPosting = GinGetNPosting(old);
+
+	oldItems = (ItemPointerData *)palloc(sizeof(ItemPointerData) * oldNPosting);
+	oldAddInfo = (Datum *)palloc(sizeof(Datum) * oldNPosting);
+	oldAddInfoIsNull = (bool *)palloc(sizeof(bool) * oldNPosting);
+
+	newNPosting = oldNPosting + nitem;
+
+	newItems = (ItemPointerData *)palloc(sizeof(ItemPointerData) * newNPosting);
+	newAddInfo = (Datum *)palloc(sizeof(Datum) * newNPosting);
+	newAddInfoIsNull = (bool *)palloc(sizeof(bool) * newNPosting);
+
+	ginReadTuple(ginstate, attnum, old, oldItems, oldAddInfo, oldAddInfoIsNull);
+
+	newNPosting = ginMergeItemPointers(newItems, newAddInfo, newAddInfoIsNull,
+		items, addInfo, addInfoIsNull, nitem,
+		oldItems, oldAddInfo, oldAddInfoIsNull, oldNPosting);
+
+
 	/* try to build tuple with room for all the items */
 	res = GinFormTuple(ginstate, attnum, key, category,
-					   NULL, nitem + GinGetNPosting(old),
+					   newItems, newAddInfo, newAddInfoIsNull, newNPosting,
 					   false);
 
-	if (res)
-	{
-		/* good, small enough */
-		uint32		newnitem;
-
-		/* fill in the posting list with union of old and new TIDs */
-		newnitem = ginMergeItemPointers(GinGetPosting(res),
-										GinGetPosting(old),
-										GinGetNPosting(old),
-										items, nitem);
-		/* merge might have eliminated some duplicate items */
-		GinShortenTuple(res, newnitem);
-	}
-	else
+	if (!res)
 	{
 		/* posting list would be too big, convert to posting tree */
 		BlockNumber postingRoot;
@@ -285,24 +455,28 @@
 		 * surely small enough to fit on one posting-tree page, and should
 		 * already be in order with no duplicates.
 		 */
-		postingRoot = createPostingTree(ginstate->index,
-										GinGetPosting(old),
-										GinGetNPosting(old));
+		postingRoot = createPostingTree(ginstate,
+										attnum,
+										ginstate->index,
+										oldItems,
+										oldAddInfo,
+										oldAddInfoIsNull,
+										oldNPosting);
 
 		/* During index build, count the newly-added data page */
 		if (buildStats)
 			buildStats->nDataPages++;
 
 		/* Now insert the TIDs-to-be-added into the posting tree */
-		gdi = ginPrepareScanPostingTree(ginstate->index, postingRoot, FALSE);
+		gdi = ginPrepareScanPostingTree(ginstate->index, postingRoot, FALSE, attnum, ginstate);
 		gdi->btree.isBuild = (buildStats != NULL);
 
-		ginInsertItemPointers(gdi, items, nitem, buildStats);
+		ginInsertItemPointers(ginstate, attnum, gdi, items, addInfo, addInfoIsNull, nitem, buildStats);
 
 		pfree(gdi);
 
 		/* And build a new posting-tree-only result tuple */
-		res = GinFormTuple(ginstate, attnum, key, category, NULL, 0, true);
+		res = GinFormTuple(ginstate, attnum, key, category, NULL, NULL, NULL, 0, true);
 		GinSetPostingTree(res, postingRoot);
 	}
 
@@ -320,49 +494,73 @@
 static IndexTuple
 buildFreshLeafTuple(GinState *ginstate,
 					OffsetNumber attnum, Datum key, GinNullCategory category,
-					ItemPointerData *items, uint32 nitem,
+					ItemPointerData *items, Datum *addInfo,
+					bool *addInfoIsNull, uint32 nitem,
 					GinStatsData *buildStats)
 {
 	IndexTuple	res;
 
 	/* try to build tuple with room for all the items */
 	res = GinFormTuple(ginstate, attnum, key, category,
-					   items, nitem, false);
+					   items, addInfo, addInfoIsNull, nitem, false);
 
 	if (!res)
 	{
 		/* posting list would be too big, build posting tree */
 		BlockNumber postingRoot;
+		ItemPointerData prevIptr = {{0,0},0};
+		Size size = 0;
+		int itemsCount = 0;
+
+		do
+		{
+			size = ginCheckPlaceToDataPageLeaf(attnum, &items[itemsCount],
+				addInfo[itemsCount], addInfoIsNull[itemsCount], &prevIptr,
+				ginstate, size);
+			prevIptr = items[itemsCount];
+			itemsCount++;
+		}
+		while (itemsCount < nitem && size < GinDataPageSize);
+		itemsCount--;
+
 
 		/*
 		 * Build posting-tree-only result tuple.  We do this first so as to
 		 * fail quickly if the key is too big.
 		 */
-		res = GinFormTuple(ginstate, attnum, key, category, NULL, 0, true);
+		res = GinFormTuple(ginstate, attnum, key, category, NULL, NULL, NULL, 0, true);
 
 		/*
 		 * Initialize posting tree with as many TIDs as will fit on the first
 		 * page.
 		 */
-		postingRoot = createPostingTree(ginstate->index,
+		postingRoot = createPostingTree(ginstate,
+										attnum,
+										ginstate->index,
 										items,
-										Min(nitem, GinMaxLeafDataItems));
+										addInfo,
+										addInfoIsNull,
+										itemsCount);
 
 		/* During index build, count the newly-added data page */
 		if (buildStats)
 			buildStats->nDataPages++;
 
 		/* Add any remaining TIDs to the posting tree */
-		if (nitem > GinMaxLeafDataItems)
+		if (nitem > itemsCount)
 		{
 			GinPostingTreeScan *gdi;
 
-			gdi = ginPrepareScanPostingTree(ginstate->index, postingRoot, FALSE);
+			gdi = ginPrepareScanPostingTree(ginstate->index, postingRoot, FALSE, attnum, ginstate);
 			gdi->btree.isBuild = (buildStats != NULL);
 
-			ginInsertItemPointers(gdi,
-								  items + GinMaxLeafDataItems,
-								  nitem - GinMaxLeafDataItems,
+			ginInsertItemPointers(ginstate,
+								  attnum,
+								  gdi,
+								  items + itemsCount,
+								  addInfo + itemsCount,
+								  addInfoIsNull + itemsCount,
+								  nitem - itemsCount,
 								  buildStats);
 
 			pfree(gdi);
@@ -418,9 +631,9 @@
 			freeGinBtreeStack(stack);
 
 			/* insert into posting tree */
-			gdi = ginPrepareScanPostingTree(ginstate->index, rootPostingTree, FALSE);
+			gdi = ginPrepareScanPostingTree(ginstate->index, rootPostingTree, FALSE, attnum, ginstate);
 			gdi->btree.isBuild = (buildStats != NULL);
-			ginInsertItemPointers(gdi, items, nitem, buildStats);
+			ginInsertItemPointers(ginstate, attnum, gdi, items, addInfo, addInfoIsNull, nitem, buildStats);
 			pfree(gdi);
 
 			return;

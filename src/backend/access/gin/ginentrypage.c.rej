--- src/backend/access/gin/ginentrypage.c
+++ src/backend/access/gin/ginentrypage.c
@@ -16,147 +16,39 @@
 
 #include "access/gin_private.h"
 #include "utils/rel.h"
+#include "utils/datum.h"
 
 /*
- * Form a tuple for entry tree.
- *
- * If the tuple would be too big to be stored, function throws a suitable
- * error if errorTooBig is TRUE, or returns NULL if errorTooBig is FALSE.
- *
- * See src/backend/access/gin/README for a description of the index tuple
- * format that is being built here.  We build on the assumption that we
- * are making a leaf-level key entry containing a posting list of nipd items.
- * If the caller is actually trying to make a posting-tree entry, non-leaf
- * entry, or pending-list entry, it should pass nipd = 0 and then overwrite
- * the t_tid fields as necessary.  In any case, ipd can be NULL to skip
- * copying any itempointers into the posting list; the caller is responsible
- * for filling the posting list afterwards, if ipd = NULL and nipd > 0.
+ * Read item pointers with additional information from leaf data page.
+ * Information is stored in the same manner as in leaf data pages.
  */
-IndexTuple
-GinFormTuple(GinState *ginstate,
-			 OffsetNumber attnum, Datum key, GinNullCategory category,
-			 ItemPointerData *ipd, uint32 nipd,
-			 bool errorTooBig)
+void
+ginReadTuple(GinState *ginstate, OffsetNumber attnum,
+	IndexTuple itup, ItemPointerData *ipd, Datum *addInfo, bool *addInfoIsNull)
 {
-	Datum		datums[2];
-	bool		isnull[2];
-	IndexTuple	itup;
-	uint32		newsize;
-
-	/* Build the basic tuple: optional column number, plus key datum */
-	if (ginstate->oneCol)
-	{
-		datums[0] = key;
-		isnull[0] = (category != GIN_CAT_NORM_KEY);
-	}
-	else
-	{
-		datums[0] = UInt16GetDatum(attnum);
-		isnull[0] = false;
-		datums[1] = key;
-		isnull[1] = (category != GIN_CAT_NORM_KEY);
-	}
-
-	itup = index_form_tuple(ginstate->tupdesc[attnum - 1], datums, isnull);
-
-	/*
-	 * Determine and store offset to the posting list, making sure there is
-	 * room for the category byte if needed.
-	 *
-	 * Note: because index_form_tuple MAXALIGNs the tuple size, there may well
-	 * be some wasted pad space.  Is it worth recomputing the data length to
-	 * prevent that?  That would also allow us to Assert that the real data
-	 * doesn't overlap the GinNullCategory byte, which this code currently
-	 * takes on faith.
-	 */
-	newsize = IndexTupleSize(itup);
-
-	if (IndexTupleHasNulls(itup))
-	{
-		uint32		minsize;
-
-		Assert(category != GIN_CAT_NORM_KEY);
-		minsize = GinCategoryOffset(itup, ginstate) + sizeof(GinNullCategory);
-		newsize = Max(newsize, minsize);
-	}
-
-	newsize = SHORTALIGN(newsize);
+	Pointer ptr;
+	int nipd = GinGetNPosting(itup), i;
+	ItemPointerData ip = {{0,0},0};
 
-	GinSetPostingOffset(itup, newsize);
-
-	GinSetNPosting(itup, nipd);
-
-	/*
-	 * Add space needed for posting list, if any.  Then check that the tuple
-	 * won't be too big to store.
-	 */
-	newsize += sizeof(ItemPointerData) * nipd;
-	newsize = MAXALIGN(newsize);
-	if (newsize > Min(INDEX_SIZE_MASK, GinMaxItemSize))
-	{
-		if (errorTooBig)
-			ereport(ERROR,
-					(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
-			errmsg("index row size %lu exceeds maximum %lu for index \"%s\"",
-				   (unsigned long) newsize,
-				   (unsigned long) Min(INDEX_SIZE_MASK,
-									   GinMaxItemSize),
-				   RelationGetRelationName(ginstate->index))));
-		pfree(itup);
-		return NULL;
-	}
+	ptr = GinGetPosting(itup);
 
-	/*
-	 * Resize tuple if needed
-	 */
-	if (newsize != IndexTupleSize(itup))
+	if (addInfo && addInfoIsNull)
 	{
-		itup = repalloc(itup, newsize);
-
-		/* set new size in tuple header */
-		itup->t_info &= ~INDEX_SIZE_MASK;
-		itup->t_info |= newsize;
+		for (i = 0; i < nipd; i++)
+		{
+			ptr = ginDataPageLeafRead(ptr, attnum, &ip, &addInfo[i],
+												&addInfoIsNull[i], ginstate);
+			ipd[i] = ip;
+		}
 	}
-
-	/*
-	 * Insert category byte, if needed
-	 */
-	if (category != GIN_CAT_NORM_KEY)
+	else
 	{
-		Assert(IndexTupleHasNulls(itup));
-		GinSetNullCategory(itup, ginstate, category);
+		for (i = 0; i < nipd; i++)
+		{
+			ptr = ginDataPageLeafRead(ptr, attnum, &ip, NULL, NULL, ginstate);
+			ipd[i] = ip;
+		}
 	}
-
-	/*
-	 * Copy in the posting list, if provided
-	 */
-	if (ipd)
-		memcpy(GinGetPosting(itup), ipd, sizeof(ItemPointerData) * nipd);
-
-	return itup;
-}
-
-/*
- * Sometimes we reduce the number of posting list items in a tuple after
- * having built it with GinFormTuple.  This function adjusts the size
- * fields to match.
- */
-void
-GinShortenTuple(IndexTuple itup, uint32 nipd)
-{
-	uint32		newsize;
-
-	Assert(nipd <= GinGetNPosting(itup));
-
-	newsize = GinGetPostingOffset(itup) + sizeof(ItemPointerData) * nipd;
-	newsize = MAXALIGN(newsize);
-
-	Assert(newsize <= (itup->t_info & INDEX_SIZE_MASK));
-
-	itup->t_info &= ~INDEX_SIZE_MASK;
-	itup->t_info |= newsize;
-
-	GinSetNPosting(itup, nipd);
 }
 
 /*

--- src/backend/access/gin/gindatapage.c
+++ src/backend/access/gin/gindatapage.c
@@ -15,8 +15,244 @@
 #include "postgres.h"
 
 #include "access/gin_private.h"
+#include "utils/datum.h"
 #include "utils/rel.h"
 
+/* Does datatype allow packing into the 1-byte-header varlena format? */
+#define TYPE_IS_PACKABLE(typlen, typstorage) \
+	((typlen) == -1 && (typstorage) != 'p')
+
+/*
+ * Increment data_length by the space needed by the datum, including any
+ * preceding alignment padding.
+ */
+static Size
+ginComputeDatumSize(Size data_length, Datum val, bool typbyval, char typalign,
+				   int16 typlen, char typstorage)
+{
+	if (TYPE_IS_PACKABLE(typlen, typstorage) &&
+		VARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))
+	{
+		/*
+		 * we're anticipating converting to a short varlena header, so adjust
+		 * length and don't count any alignment
+		 */
+		data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));
+	}
+	else
+	{
+		data_length = att_align_datum(data_length, typalign, typlen, val);
+		data_length = att_addlength_datum(data_length, typlen, val);
+	}
+
+	return data_length;
+}
+
+/*
+ * Write the given datum beginning at ptr (after advancing to correct
+ * alignment, if needed). Setting padding bytes to zero if needed. Return the
+ * pointer incremented by space used.
+ */
+static Pointer
+ginDatumWrite(Pointer ptr, Datum datum, bool typbyval, char typalign,
+			int16 typlen, char typstorage)
+{
+	Size		data_length;
+	Pointer		prev_ptr = ptr;
+
+	if (typbyval)
+	{
+		/* pass-by-value */
+		store_att_byval(ptr, datum, typlen);
+		/**/ptr = ptr + typlen;
+		ptr = (char *) att_align_nominal(ptr, typalign);
+//		store_att_byval(ptr, datum, typlen);
+		data_length = typlen;
+	}
+	else if (typlen == -1)
+	{
+		/* varlena */
+		Pointer		val = DatumGetPointer(datum);
+
+		if (VARATT_IS_EXTERNAL(val))
+		{
+			/*
+			 * Throw error, because we must never put a toast pointer inside a
+			 * range object.  Caller should have detoasted it.
+			 */
+			elog(ERROR, "cannot store a toast pointer inside a range");
+			data_length = 0;	/* keep compiler quiet */
+		}
+		else if (VARATT_IS_SHORT(val))
+		{
+			/* no alignment for short varlenas */
+			data_length = VARSIZE_SHORT(val);
+			memmove(ptr, val, data_length);
+		}
+		else if (TYPE_IS_PACKABLE(typlen, typstorage) &&
+				 VARATT_CAN_MAKE_SHORT(val))
+		{
+			/* convert to short varlena -- no alignment */
+			data_length = VARATT_CONVERTED_SHORT_SIZE(val);
+			SET_VARSIZE_SHORT(ptr, data_length);
+			memmove(ptr + 1, VARDATA(val), data_length - 1);
+		}
+		else
+		{
+			/* full 4-byte header varlena */
+			ptr = (char *) att_align_nominal(ptr, typalign);
+			data_length = VARSIZE(val);
+			memmove(ptr, val, data_length);
+		}
+	}
+	else if (typlen == -2)
+	{
+		/* cstring ... never needs alignment */
+		Assert(typalign == 'c');
+		data_length = strlen(DatumGetCString(datum)) + 1;
+		memmove(ptr, DatumGetPointer(datum), data_length);
+	}
+	else
+	{
+		/* fixed-length pass-by-reference */
+		ptr = (char *) att_align_nominal(ptr, typalign);
+		Assert(typlen > 0);
+		data_length = typlen;
+		memmove(ptr, DatumGetPointer(datum), data_length);
+	}
+
+	if (!typbyval)
+	{
+		if (ptr != prev_ptr)
+			memset(prev_ptr, 0, ptr - prev_ptr);
+		ptr += data_length;
+	}
+
+	return ptr;
+}
+
+/*
+ * Write item pointer into leaf data page using varbyte encoding. Since
+ * BlockNumber is stored in incremental manner we also need a previous item
+ * pointer. Also store addInfoIsNull flag using one bit of OffsetNumber.
+ */
+char *
+ginDataPageLeafWriteItemPointer(char *ptr, ItemPointer iptr, ItemPointer prev,
+															bool addInfoIsNull)
+{
+	uint32 blockNumberIncr = 0;
+	uint16 offset = iptr->ip_posid;
+
+	blockNumberIncr = iptr->ip_blkid.bi_lo + (iptr->ip_blkid.bi_hi << 16) -
+					  (prev->ip_blkid.bi_lo + (prev->ip_blkid.bi_hi << 16));
+
+
+	while (true)
+	{
+		*ptr = (blockNumberIncr & (~HIGHBIT)) |
+								((blockNumberIncr >= HIGHBIT) ? HIGHBIT : 0);
+		ptr++;
+		if (blockNumberIncr < HIGHBIT)
+			break;
+		blockNumberIncr >>= 7;
+	}
+
+	while (true)
+	{
+		if (offset >= SEVENTHBIT)
+		{
+			*ptr = (offset & (~HIGHBIT)) | HIGHBIT;
+			ptr++;
+			offset >>= 7;
+		}
+		else
+		{
+			*ptr = offset | (addInfoIsNull ? SEVENTHBIT : 0);
+			ptr++;
+			break;
+		}
+	}
+
+	return ptr;
+}
+
+/*
+ * Place item pointer with additional information into leaf data page.
+ */
+Pointer
+ginPlaceToDataPageLeaf(Pointer ptr, OffsetNumber attnum,
+	ItemPointer iptr, Datum addInfo, bool addInfoIsNull, ItemPointer prev,
+	GinState *ginstate)
+{
+	Form_pg_attribute attr;
+
+	ptr = ginDataPageLeafWriteItemPointer(ptr, iptr, prev, addInfoIsNull);
+
+	if (!addInfoIsNull)
+	{
+		attr = ginstate->addAttrs[attnum - 1];
+		ptr = ginDatumWrite(ptr, addInfo, attr->attbyval, attr->attalign,
+			attr->attlen, attr->attstorage);
+	}
+	return ptr;
+}
+
+/*
+ * Calculate size of incremental varbyte encoding of item pointer.
+ */
+static int
+ginDataPageLeafGetItemPointerSize(ItemPointer iptr, ItemPointer prev)
+{
+	uint32 blockNumberIncr = 0;
+	uint16 offset = iptr->ip_posid;
+	int size = 0;
+
+	blockNumberIncr = iptr->ip_blkid.bi_lo + (iptr->ip_blkid.bi_hi << 16) -
+					  (prev->ip_blkid.bi_lo + (prev->ip_blkid.bi_hi << 16));
+
+
+	while (true)
+	{
+		size++;
+		if (blockNumberIncr < HIGHBIT)
+			break;
+		blockNumberIncr >>= 7;
+	}
+
+	while (true)
+	{
+		size++;
+		if (offset < SEVENTHBIT)
+			break;
+		offset >>= 7;
+	}
+
+	return size;
+}
+
+/*
+ * Returns size of item pointers with additional information if leaf data page
+ * after inserting another one.
+ */
+Size
+ginCheckPlaceToDataPageLeaf(OffsetNumber attnum,
+	ItemPointer iptr, Datum addInfo, bool addInfoIsNull, ItemPointer prev,
+	GinState *ginstate, Size size)
+{
+	Form_pg_attribute attr;
+
+	size += ginDataPageLeafGetItemPointerSize(iptr, prev);
+
+	if (!addInfoIsNull)
+	{
+		attr = ginstate->addAttrs[attnum - 1];
+		size = ginComputeDatumSize(size, addInfo, attr->attbyval,
+			attr->attalign, attr->attlen, attr->attstorage);
+	}
+
+	return size;
+}
+
 int
 ginCompareItemPointers(ItemPointer a, ItemPointer b)
 {
@@ -37,14 +273,16 @@
 }
 
 /*
- * Merge two ordered arrays of itempointers, eliminating any duplicates.
+ * Merge two ordered arrays of itempointers eliminating any duplicates  with
+ * corresponding merging of arrays about additional information.
  * Returns the number of items in the result.
  * Caller is responsible that there is enough space at *dst.
  */
 uint32
-ginMergeItemPointers(ItemPointerData *dst,
-					 ItemPointerData *a, uint32 na,
-					 ItemPointerData *b, uint32 nb)
+ginMergeItemPointers(ItemPointerData *dst, Datum *dstAddInfo,
+		bool *dstAddInfoIsNull, ItemPointerData *a, Datum *aAddInfo,
+		bool *aAddInfoIsNull, uint32 na, ItemPointerData *b, Datum *bAddInfo,
+		bool *bAddInfoIsNull, uint32 nb)
 {
 	ItemPointerData *dptr = dst;
 	ItemPointerData *aptr = a,
@@ -55,22 +293,42 @@
 		int			cmp = ginCompareItemPointers(aptr, bptr);
 
 		if (cmp > 0)
+		{
 			*dptr++ = *bptr++;
+			*dstAddInfo++ = *bAddInfo++;
+			*dstAddInfoIsNull++ = *bAddInfoIsNull++;
+		}
 		else if (cmp == 0)
 		{
 			/* we want only one copy of the identical items */
 			*dptr++ = *bptr++;
+			*dstAddInfo++ = *bAddInfo++;
+			*dstAddInfoIsNull++ = *bAddInfoIsNull++;
 			aptr++;
+			aAddInfo++;
+			aAddInfoIsNull++;
 		}
 		else
+		{
 			*dptr++ = *aptr++;
+			*dstAddInfo++ = *aAddInfo++;
+			*dstAddInfoIsNull++ = *aAddInfoIsNull++;
+		}
 	}
 
 	while (aptr - a < na)
+	{
 		*dptr++ = *aptr++;
+		*dstAddInfo++ = *aAddInfo++;
+		*dstAddInfoIsNull++ = *aAddInfoIsNull++;
+	}
 
 	while (bptr - b < nb)
+	{
 		*dptr++ = *bptr++;
+		*dstAddInfo++ = *bAddInfo++;
+		*dstAddInfoIsNull++ = *bAddInfoIsNull++;
+	}
 
 	return dptr - dst;
 }
@@ -235,9 +561,8 @@
 dataLocateLeafItem(GinBtree btree, GinBtreeStack *stack)
 {
 	Page		page = BufferGetPage(stack->buffer);
-	OffsetNumber low,
-				high;
-	int			result;
+	ItemPointerData iptr;
+	Pointer ptr;
 
 	Assert(GinPageIsLeaf(page));
 	Assert(GinPageIsData(page));
@@ -248,36 +573,8 @@
 		return TRUE;
 	}
 
-	low = FirstOffsetNumber;
-	high = GinPageGetOpaque(page)->maxoff;
-
-	if (high < low)
-	{
-		stack->off = FirstOffsetNumber;
-		return false;
-	}
-
-	high++;
-
-	while (high > low)
-	{
-		OffsetNumber mid = low + ((high - low) / 2);
-
-		result = ginCompareItemPointers(btree->items + btree->curitem, (ItemPointer) GinDataPageGetItem(page, mid));
+	return findInLeafPage(btree, page, &stack->off, &iptr, &ptr);
 
-		if (result == 0)
-		{
-			stack->off = mid;
-			return true;
-		}
-		else if (result > 0)
-			low = mid + 1;
-		else
-			high = mid;
-	}
-
-	stack->off = high;
-	return false;
 }
 
 /*
@@ -401,13 +698,40 @@
 
 	if (GinPageIsLeaf(page))
 	{
-		if (GinPageRightMost(page) && off > GinPageGetOpaque(page)->maxoff)
+		int i, n, j;
+		ItemPointerData iptr = {{0,0},0};
+		Size size = 0;
+
+		/*
+		 * Calculate additional size using worst case assumption: varbyte
+		 * encoding from zero item pointer. Also use worst case assumption about
+		 * alignment.
+		 */
+		n = GinPageGetOpaque(page)->maxoff;
+
+		if (GinPageRightMost(page) && off > n)
 		{
-			if ((btree->nitem - btree->curitem) * sizeof(ItemPointerData) <= GinDataPageGetFreeSpace(page))
-				return true;
+			for (j = btree->curitem; j < btree->nitem; j++)
+			{
+				size = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+					&btree->items[j], btree->addInfo[j], btree->addInfoIsNull[j],
+					(j == btree->curitem) ? (&iptr) : &btree->items[j - 1],
+					btree->ginstate, size);
+				i++;
+			}
 		}
-		else if (sizeof(ItemPointerData) <= GinDataPageGetFreeSpace(page))
+		else
+		{
+			j = btree->curitem;
+			size = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+				&btree->items[j], btree->addInfo[j], btree->addInfoIsNull[j],
+				&iptr, btree->ginstate, size);
+		}
+		size += MAXIMUM_ALIGNOF;
+
+		if (GinPageGetOpaque(page)->freespace >= size)
 			return true;
+
 	}
 	else if (sizeof(PostingItem) <= GinDataPageGetFreeSpace(page))
 		return true;
@@ -448,11 +772,13 @@
 dataPlaceToPage(GinBtree btree, Buffer buf, OffsetNumber off, XLogRecData **prdata)
 {
 	Page		page = BufferGetPage(buf);
-	int			sizeofitem = GinSizeOfDataPageItem(page);
+	int			cnt = 0;
+	Form_pg_attribute attr = btree->ginstate->addAttrs[btree->entryAttnum - 1];
 
 	/* these must be static so they can be returned to caller */
 	static XLogRecData rdata[3];
 	static ginxlogInsert data;
+	static char insertData[BLCKSZ];
 
 	*prdata = rdata;
 	Assert(GinPageIsData(page));
@@ -462,11 +788,19 @@
 	data.node = btree->index->rd_node;
 	data.blkno = BufferGetBlockNumber(buf);
 	data.offset = off;
-	data.nitem = 1;
+	data.nitem = 0;
 	data.isDelete = FALSE;
 	data.isData = TRUE;
 	data.isLeaf = GinPageIsLeaf(page) ? TRUE : FALSE;
 
+	if (attr)
+	{
+		data.typlen = attr->attlen;
+		data.typalign = attr->attalign;
+		data.typbyval = attr->attbyval;
+		data.typstorage = attr->attstorage;
+	}
+
 	/*
 	 * For incomplete-split tracking, we need updateBlkno information and the
 	 * inserted item even when we make a full page image of the page, so put
@@ -483,35 +817,380 @@
 	rdata[1].len = sizeof(ginxlogInsert);
 	rdata[1].next = &rdata[2];
 
-	rdata[2].buffer = InvalidBuffer;
-	rdata[2].data = (GinPageIsLeaf(page)) ? ((char *) (btree->items + btree->curitem)) : ((char *) &(btree->pitem));
-	rdata[2].len = sizeofitem;
-	rdata[2].next = NULL;
 
 	if (GinPageIsLeaf(page))
 	{
-		if (GinPageRightMost(page) && off > GinPageGetOpaque(page)->maxoff)
+		int i = 0, j, max_j;
+		Pointer ptr = GinDataPageGetData(page), next_ptr, insertStart;
+		ItemPointerData iptr = {{0,0},0}, next_iptr;
+		char pageCopy[BLCKSZ];
+		Datum addInfo = 0;
+		bool addInfoIsNull = false;
+		int maxoff = GinPageGetOpaque(page)->maxoff;
+		int copySize = 0;
+
+		/*
+		 * We're going to prevent var-byte re-encoding of whole page.
+		 * Find position in page using page indexes.
+		 */
+		findInLeafPage(btree, page, &off, &iptr, &ptr);
+
+		Assert(GinDataPageFreeSpacePre(page,ptr) >= 0);
+
+		if (off <= maxoff)
+		{
+			/*
+			 * Read next item-pointer with additional information: we'll have
+			 * to re-encode it. Copy previous part of page/
+			 */
+			next_iptr = iptr;
+			next_ptr = ginDataPageLeafRead(ptr, btree->entryAttnum, &next_iptr,
+									&addInfo, &addInfoIsNull, btree->ginstate);
+			if (!addInfoIsNull)
+				addInfo = datumCopy(addInfo, attr->attbyval, attr->attlen);
+			copySize = GinDataPageSize -  GinPageGetOpaque(page)->freespace -
+				(next_ptr - GinDataPageGetData(page));
+			memcpy(pageCopy, next_ptr, copySize);
+		}
+
+		/* Check how many items we're going to add */
+		if (GinPageRightMost(page) && off > maxoff)
+			max_j = btree->nitem;
+		else
+			max_j = btree->curitem + 1;
+
+		/* Place items to the page while we have enough of space */
+		*((ItemPointerData *)insertData) = iptr;
+		insertStart = ptr;
+		i = 0;
+		for (j = btree->curitem; j < max_j; j++)
+		{
+			Pointer ptr2;
+
+			ptr2 = page + ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+				&btree->items[j], btree->addInfo[j], btree->addInfoIsNull[j],
+				&iptr, btree->ginstate, ptr - page);
+
+			if (GinDataPageFreeSpacePre(page, ptr2) < 0)
+				break;
+
+			ptr = ginPlaceToDataPageLeaf(ptr, btree->entryAttnum,
+				&btree->items[j], btree->addInfo[j], btree->addInfoIsNull[j],
+				&iptr, btree->ginstate);
+			Assert(GinDataPageFreeSpacePre(page,ptr) >= 0);
+
+			iptr = btree->items[j];
+			btree->curitem++;
+			data.nitem++;
+			i++;
+		}
+
+		/* Put WAL data */
+		memcpy(insertData + sizeof(ItemPointerData), insertStart,
+															ptr - insertStart);
+		rdata[cnt].buffer = InvalidBuffer;
+		rdata[cnt].data = insertData;
+		rdata[cnt].len = sizeof(ItemPointerData) + (ptr - insertStart);
+		rdata[cnt].next = NULL;
+
+		/* Place rest of the page back */
+		if (off <= maxoff)
+		{
+			ptr = ginPlaceToDataPageLeaf(ptr, btree->entryAttnum,
+				&next_iptr, addInfo, addInfoIsNull,
+				&iptr, btree->ginstate);
+			Assert(GinDataPageFreeSpacePre(page,ptr) >= 0);
+			memcpy(ptr, pageCopy, copySize);
+		}
+
+		GinPageGetOpaque(page)->maxoff += i;
+
+		if (GinDataPageFreeSpacePre(page,ptr) < 0)
+			elog(ERROR, "Not enough of space in leaf page!");
+
+		/* Update indexes in the end of page */
+		updateItemIndexes(page, btree->entryAttnum, btree->ginstate);
+	}
+	else
+	{
+		rdata[cnt].buffer = InvalidBuffer;
+		rdata[cnt].data = (char *) &(btree->pitem);
+		rdata[cnt].len = sizeof(PostingItem);
+		rdata[cnt].next = NULL;
+		data.nitem = 1;
+
+		GinDataPageAddItem(page, &(btree->pitem), off);
+	}
+}
+
+/* Macro for leaf data page split: switch to right page if needed. */
+#define CHECK_SWITCH_TO_RPAGE                    \
+	do {                                         \
+		if (ptr - GinDataPageGetData(page) >     \
+			totalsize / 2 && page == lpage)      \
+		{                                        \
+			maxLeftIptr = iptr;                  \
+			prevIptr.ip_blkid.bi_hi = 0;         \
+			prevIptr.ip_blkid.bi_lo = 0;         \
+			prevIptr.ip_posid = 0;               \
+			GinPageGetOpaque(lpage)->maxoff = j; \
+			page = rpage;                        \
+			ptr = GinDataPageGetData(rpage);     \
+			j = FirstOffsetNumber;               \
+		}                                        \
+		else                                     \
+		{                                        \
+			j++;                                 \
+		}                                        \
+	} while (0)
+
+
+
+/*
+ * Place tuple and split page, original buffer(lbuf) leaves untouched,
+ * returns shadow page of lbuf filled new data.
+ * Item pointers with additional information are distributed between pages by
+ * equal size on its, not an equal number!
+ */
+static Page
+dataSplitPageLeaf(GinBtree btree, Buffer lbuf, Buffer rbuf, OffsetNumber off,
+														XLogRecData **prdata)
+{
+	OffsetNumber i, j,
+				maxoff;
+	Size		totalsize = 0, prevTotalsize;
+	Pointer		ptr, copyPtr;
+	Page		page;
+	Page		lpage = PageGetTempPageCopy(BufferGetPage(lbuf));
+	Page		rpage = BufferGetPage(rbuf);
+	Size		pageSize = PageGetPageSize(lpage);
+	Size		maxItemSize = 0;
+	Datum		addInfo = 0;
+	bool		addInfoIsNull;
+	ItemPointerData iptr, prevIptr, maxLeftIptr;
+	int			totalCount = 0;
+	int			maxItemIndex = btree->curitem;
+	Form_pg_attribute attr = btree->ginstate->addAttrs[btree->entryAttnum - 1];
+
+	/* these must be static so they can be returned to caller */
+	static XLogRecData rdata[3];
+	static ginxlogSplit data;
+	static char lpageCopy[BLCKSZ];
+
+	*prdata = rdata;
+	data.leftChildBlkno = (GinPageIsLeaf(lpage)) ?
+		InvalidOffsetNumber : GinGetDownlink(btree->entry);
+	data.updateBlkno = dataPrepareData(btree, lpage, off);
+
+	maxoff = GinPageGetOpaque(lpage)->maxoff;
+
+	/* Copy original data of the page */
+	memcpy(lpageCopy, lpage, BLCKSZ);
+
+	/* Reinitialize pages */
+	GinInitPage(rpage, GinPageGetOpaque(lpage)->flags, pageSize);
+	GinInitPage(lpage, GinPageGetOpaque(rpage)->flags, pageSize);
+
+	GinPageGetOpaque(lpage)->maxoff = 0;
+	GinPageGetOpaque(rpage)->maxoff = 0;
+
+	/* Calculate the whole size we're going to place */
+	copyPtr = GinDataPageGetData(lpageCopy);
+	iptr.ip_blkid.bi_hi = 0;
+	iptr.ip_blkid.bi_lo = 0;
+	iptr.ip_posid = 0;
+	for (i = FirstOffsetNumber; i <= maxoff; i++)
+	{
+		if (i == off)
 		{
-			/* usually, create index... */
-			uint32		savedPos = btree->curitem;
+			prevIptr = iptr;
+			iptr = btree->items[maxItemIndex];
+
+			prevTotalsize = totalsize;
+			totalsize = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+				&iptr, btree->addInfo[maxItemIndex],
+				btree->addInfoIsNull[maxItemIndex],
+				&prevIptr, btree->ginstate, totalsize);
+
+			maxItemIndex++;
+			totalCount++;
+			maxItemSize = Max(maxItemSize, totalsize - prevTotalsize);
+		}
+
+		prevIptr = iptr;
+		copyPtr = ginDataPageLeafRead(copyPtr, btree->entryAttnum,
+			&iptr, &addInfo, &addInfoIsNull, btree->ginstate);
+
+		prevTotalsize = totalsize;
+		totalsize = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+			&iptr, addInfo, addInfoIsNull,
+			&prevIptr, btree->ginstate, totalsize);
+
+		totalCount++;
+		maxItemSize = Max(maxItemSize, totalsize - prevTotalsize);
+	}
+
+	if (off == maxoff + 1)
+	{
+		prevIptr = iptr;
+		iptr = btree->items[maxItemIndex];
+		if (GinPageRightMost(lpage))
+		{
+			Size newTotalsize;
+
+			/*
+			 * Found how many new item pointer we're going to add using
+			 * worst case assumptions about odd placement and alignment.
+			 */
+			while (maxItemIndex < btree->nitem &&
+				(newTotalsize = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+					&iptr, btree->addInfo[maxItemIndex],
+					btree->addInfoIsNull[maxItemIndex],
+					&prevIptr, btree->ginstate, totalsize)) <
+					2 * GinDataPageSize - 2 * maxItemSize - 2 * MAXIMUM_ALIGNOF
+			)
 
-			while (btree->curitem < btree->nitem)
 			{
-				GinDataPageAddItem(page, btree->items + btree->curitem, off);
-				off++;
-				btree->curitem++;
+				maxItemIndex++;
+				totalCount++;
+				maxItemSize = Max(maxItemSize, newTotalsize - totalsize);
+				totalsize = newTotalsize;
+
+				prevIptr = iptr;
+				if (maxItemIndex < btree->nitem)
+					iptr = btree->items[maxItemIndex];
+
 			}
-			data.nitem = btree->curitem - savedPos;
-			rdata[2].len = sizeofitem * data.nitem;
 		}
 		else
 		{
-			GinDataPageAddItem(page, btree->items + btree->curitem, off);
+			prevTotalsize = totalsize;
+			totalsize = ginCheckPlaceToDataPageLeaf(btree->entryAttnum,
+				&iptr, btree->addInfo[maxItemIndex],
+				btree->addInfoIsNull[maxItemIndex],
+				&prevIptr, btree->ginstate, totalsize);
+			maxItemIndex++;
+
+			totalCount++;
+			maxItemSize = Max(maxItemSize, totalsize - prevTotalsize);
+		}
+	}
+
+	/*
+	 * Place item pointers with additional information to the pages using
+	 * previous calculations.
+	 */
+	ptr = GinDataPageGetData(lpage);
+	page = lpage;
+	j = FirstOffsetNumber;
+	iptr.ip_blkid.bi_hi = 0;
+	iptr.ip_blkid.bi_lo = 0;
+	iptr.ip_posid = 0;
+	prevIptr = iptr;
+	copyPtr = GinDataPageGetData(lpageCopy);
+	for (i = FirstOffsetNumber; i <= maxoff; i++)
+	{
+		if (i == off)
+		{
+			while (btree->curitem < maxItemIndex)
+			{
+				iptr = btree->items[btree->curitem];
+
+				ptr = ginPlaceToDataPageLeaf(ptr, btree->entryAttnum,
+					&iptr,
+					btree->addInfo[btree->curitem],
+					btree->addInfoIsNull[btree->curitem],
+					&prevIptr, btree->ginstate);
+				Assert(GinDataPageFreeSpacePre(page, ptr) >= 0);
+
+				btree->curitem++;
+				prevIptr = iptr;
+
+				CHECK_SWITCH_TO_RPAGE;
+			}
+		}
+
+		copyPtr = ginDataPageLeafRead(copyPtr, btree->entryAttnum,
+			&iptr, &addInfo, &addInfoIsNull, btree->ginstate);
+
+		ptr = ginPlaceToDataPageLeaf(ptr, btree->entryAttnum, &iptr,
+			addInfo, addInfoIsNull, &prevIptr, btree->ginstate);
+		Assert(GinDataPageFreeSpacePre(page, ptr) >= 0);
+
+		prevIptr = iptr;
+
+		CHECK_SWITCH_TO_RPAGE;
+	}
+
+	if (off == maxoff + 1)
+	{
+		while (btree->curitem < maxItemIndex)
+		{
+			iptr = btree->items[btree->curitem];
+
+			ptr = ginPlaceToDataPageLeaf(ptr, btree->entryAttnum,
+				&iptr,
+				btree->addInfo[btree->curitem],
+				btree->addInfoIsNull[btree->curitem],
+				&prevIptr, btree->ginstate);
+			Assert(GinDataPageFreeSpacePre(page, ptr) >= 0);
 			btree->curitem++;
+
+			prevIptr = iptr;
+
+			CHECK_SWITCH_TO_RPAGE;
+
 		}
 	}
-	else
-		GinDataPageAddItem(page, &(btree->pitem), off);
+
+	GinPageGetOpaque(rpage)->maxoff = j - 1;
+
+	PostingItemSetBlockNumber(&(btree->pitem), BufferGetBlockNumber(lbuf));
+	btree->pitem.key = maxLeftIptr;
+	btree->rightblkno = BufferGetBlockNumber(rbuf);
+
+	*GinDataPageGetRightBound(rpage) = *GinDataPageGetRightBound(lpage);
+	*GinDataPageGetRightBound(lpage) = maxLeftIptr;
+
+	/* Fill indexes at the end of pages */
+	updateItemIndexes(lpage, btree->entryAttnum, btree->ginstate);
+	updateItemIndexes(rpage, btree->entryAttnum, btree->ginstate);
+
+	data.node = btree->index->rd_node;
+	data.rootBlkno = InvalidBlockNumber;
+	data.lblkno = BufferGetBlockNumber(lbuf);
+	data.rblkno = BufferGetBlockNumber(rbuf);
+	data.separator = GinPageGetOpaque(lpage)->maxoff;
+	data.nitem = GinPageGetOpaque(lpage)->maxoff + GinPageGetOpaque(rpage)->maxoff;
+	data.isData = TRUE;
+	data.isLeaf = TRUE;
+	data.isRootSplit = FALSE;
+	if (attr)
+	{
+		data.typlen = attr->attlen;
+		data.typalign = attr->attalign;
+		data.typbyval = attr->attbyval;
+		data.typstorage = attr->attstorage;
+	}
+	data.rightbound = *GinDataPageGetRightBound(rpage);
+
+	rdata[0].buffer = InvalidBuffer;
+	rdata[0].data = (char *) &data;
+	rdata[0].len = sizeof(ginxlogSplit);
+	rdata[0].next = &rdata[1];
+
+	rdata[1].buffer = InvalidBuffer;
+	rdata[1].data = GinDataPageGetData(lpage);
+	rdata[1].len = (GinDataPageSize - GinPageGetOpaque(lpage)->freespace);
+	rdata[1].next = &rdata[2];
+
+	rdata[2].buffer = InvalidBuffer;
+	rdata[2].data = GinDataPageGetData(rpage);
+	rdata[2].len = (GinDataPageSize - GinPageGetOpaque(rpage)->freespace);
+	rdata[2].next = NULL;
+
+	return lpage;
+
 }
 
 /*
@@ -521,7 +1200,8 @@
  * left page
  */
 static Page
-dataSplitPage(GinBtree btree, Buffer lbuf, Buffer rbuf, OffsetNumber off, XLogRecData **prdata)
+dataSplitPageInternal(GinBtree btree, Buffer lbuf, Buffer rbuf,
+										OffsetNumber off, XLogRecData **prdata)
 {
 	char	   *ptr;
 	OffsetNumber separator;
@@ -537,7 +1217,7 @@
 
 	/* these must be static so they can be returned to caller */
 	static ginxlogSplit data;
-	static XLogRecData rdata[4];
+	static XLogRecData rdata[2];
 	static char vector[2 * BLCKSZ];
 
 	GinInitPage(rpage, GinPageGetOpaque(lpage)->flags, pageSize);
@@ -623,7 +1303,7 @@
 	data.separator = separator;
 	data.nitem = maxoff;
 	data.isData = TRUE;
-	data.isLeaf = GinPageIsLeaf(lpage) ? TRUE : FALSE;
+	data.isLeaf = FALSE;
 	data.isRootSplit = FALSE;
 	data.rightbound = oldbound;
 
@@ -719,11 +1455,12 @@
 }
 
 void
-ginPrepareDataScan(GinBtree btree, Relation index)
+ginPrepareDataScan(GinBtree btree, Relation index, OffsetNumber attnum, GinState *ginstate)
 {
 	memset(btree, 0, sizeof(GinBtreeData));
 
 	btree->index = index;
+	btree->ginstate = ginstate;
 
 	btree->findChildPage = dataLocateItem;
 	btree->isMoveRight = dataIsMoveRight;
@@ -740,14 +1477,17 @@
 	btree->isDelete = FALSE;
 	btree->fullScan = FALSE;
 	btree->isBuild = FALSE;
+
+	btree->entryAttnum = attnum;
 }
 
 GinPostingTreeScan *
-ginPrepareScanPostingTree(Relation index, BlockNumber rootBlkno, bool searchMode)
+ginPrepareScanPostingTree(Relation index, BlockNumber rootBlkno,
+					bool searchMode, OffsetNumber attnum, GinState *ginstate)
 {
 	GinPostingTreeScan *gdi = (GinPostingTreeScan *) palloc0(sizeof(GinPostingTreeScan));
 
-	ginPrepareDataScan(&gdi->btree, index);
+	ginPrepareDataScan(&gdi->btree, index, attnum, ginstate);
 
 	gdi->btree.searchMode = searchMode;
 	gdi->btree.fullScan = searchMode;
@@ -761,13 +1501,22 @@
  * Inserts array of item pointers, may execute several tree scan (very rare)
  */
 void
-ginInsertItemPointers(GinPostingTreeScan *gdi,
-					  ItemPointerData *items, uint32 nitem,
+ginInsertItemPointers(GinState *ginstate,
+					  OffsetNumber attnum,
+					  GinPostingTreeScan *gdi,
+					  ItemPointerData *items,
+					  Datum *addInfo,
+					  bool *addInfoIsNull,
+					  uint32 nitem,
 					  GinStatsData *buildStats)
 {
 	BlockNumber rootBlkno = gdi->stack->blkno;
 
+
 	gdi->btree.items = items;
+	gdi->btree.addInfo = addInfo;
+	gdi->btree.addInfoIsNull = addInfoIsNull;
+
 	gdi->btree.nitem = nitem;
 	gdi->btree.curitem = 0;
 

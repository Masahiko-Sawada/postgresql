<!-- doc/src/sgml/key-management.sgml -->

<chapter id="key-management">
 <title>Encryption Key Management</title>

 <indexterm zone="key-management">
  <primary>key management</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> supports internal
  <firstterm>Encryption Key Management System</firstterm>, which is designed to manage
  the life cycles of cryptographic keys within the PostgreSQL system. This includes dealing
  with their generation, storage, usage and rotation.
 </para>

 <para>
  Encryption Key Management System is enabled when <productname>PostgreSQL</productname> is
  built with <literal>--with-openssl</literal> and <xref linkend="app-initdb-cluster-passphrase-command"/>
  is specified during <command>initdb</command>. The cluster passphrase provided by
  <option>--cluster-passphrase-command</option> option during <command>initdb</command>
  and the one generated by <xref linkend="guc-cluster-passphrase-command"/> in the
  <filename>postgresql.conf</filename> must match, otherwise, the database cluster
  will not start up. Please note that the cluster passphrase command passed to <command>initdb</command>
  must return a passphrase equal or longer than 64 bytes and less than 1024 bytes. For example.
<programlisting>
initdb -D dbname --cluster-passphrase-command="cat /path/to/passphrase-file"
</programlisting>
 </para>

 <sect1 id="key-management-details">
  <title>Key Management Details</title>

  <sect2 id="key-management-">
   <title>Key Encryption Key(<acronym>KEK</acronym>)</title>

   <para>
    When a PostgreSQL cluster with encryption key management enabled is started, the
    <varname>cluster_passphrase_command</varname> parameter in <filename>postgresql.conf</filename>
    will be evaluated and the cluster passphrase will be derived into
    <firstterm>Key Encryption Key (<acronym>KEK</acronym>)</firstterm> in similar ways as initdb.
   </para>

   <para>
    After that, the cryptographic keys will be retrieved from <filename>pg_cryptokeys</filename>
    directory to be restored and integrity-checked by the key management system using
    <acronym>KEK</acronym>.  If this process fails, it is likely that the cluster passphrase
    supplied to the cluster is not the same as that supplied to the <command>initdb</command>
    process. The cluster will refuse to start in this case and user has to manually correct
    the cluster passphrase.
   </para>

   <para>
    <acronym>KEK</acronym> consists of an encryption key and a HMAC key:
   </para>

   <variablelist>
    <varlistentry>
     <term><literal>Encryption Key</literal></term>
     <listitem>
      <para>
       Encryption key is a key for <firstterm>Advanced Encryption Standard (<acronym>AES</acronym>)</firstterm>
       key. It is primarily used to encapsulate or restore a cryptographic key.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>HMAC Key</literal></term>
     <listitem>
      <para>
       HMAC key is used to compute the HASH of a cryptographic key for integrity check purposes.
       <literal>SHA256</literal> is the algorithm used along with the <literal>HMAC</literal>
       key to compute a cryptographic hash for integrity check purposes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>
    These two keys are not stored physically within the PostgreSQL cluster as they are designed
    to be derived from the correctly configured cluster passphrase.
   </para>
  </sect2>

   <sect2 id="key-management-derivations">
   <title>Key Derivations</title>

   <para>
    Encryption key management system can manage multiple cryptographic keys that have different
    purposes and usages within the PostgreSQL system. Currently, encryption key management
    system manages one cryptographic key which is generated using
    <function>pg_strong_random()</function> during <command>initdb</command> process.
   </para>

   <variablelist>
    <varlistentry>
     <term><literal>SQL Level Key</literal></term>
     <listitem>
      <para>
       SQL Level Key is used to wrap and unwrap a user secret or passphrase via
       <function>pg_wrap()</function> and <function>pg_unwrap()</function>
       SQL functions in similar ways as <acronym>KEK</acronym>.  These two functions are
       designed to be used in conjunction with the cryptographic functions provided by
       <filename>pgcrypto</filename> extension to perform column level encryption/decryption
       without having to supply a clear text user secret or passphrase that is required
       by many pgcrypto functions as input. Please refer to
       <xref linkend="key-management-wrap-and-unwrap"/> for usage examples.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="key-management-wrap-and-unwrap">
  <title>Wrap and Unwrap User Secret</title>

  <para>
   Encryption key management system provides <function>pg_wrap()</function> and
   <function>pg_unwrap()</function> SQL functions described in
   <xref linkend="functions-key-management-table"/> to perform wrap and unwrap operations on user
   secret with the SQL level encryption key.
  </para>

  <para>
   When <function>pg_wrap()</function> and <function>pg_unwrap()</function> functions are invoked, SQL
   level encryption key will internally be used to perform the encryption and decryption operation with
   HMAC-based integrity check. From user's point of view, he or she is not aware of the actual SQL level
   encryption key used internally by both wrap functions.
  </para>

  <para>
   One possible use case is to combine <function>pg_wrap()</function> and <function>pg_unwrap()</function>
   with <xref linkend="pgcrypto"/>. User wraps the user encryption secret with <function>pg_wrap()</function>
   function and passes the wrapped encryption secret to <function>pg_unwrap()</function> function for the
   <structname>pgcrypto</structname> encryption functions. The wrapped secret can be stored in the application
   server or somewhere secured and should be obtained promptly for cryptographic operation with
   <structname>pgcrypto</structname>.
  </para>

  <para>
   Here is an example that shows how to encrypt and decrypt data together with
   wrap and unwrap functions:
  </para>

<programlisting>
=# SELECT pg_wrap('my secret passward');
                                                                              pg_wrap
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 \xb2c89f76f04f95d029f179e0fc3df4ed7254127b5562a9e27d42d1cd037c942dea65ce7c0750c520fa4f4e90481c9eb7e1e42a068248c262c1a6f25c6eab64303b1154ccc9a14361223641aab4a7aabe
(1 row)
</programlisting>

  <para>
   Once wrapping the user key, user can encrypt and decrypt user data using the
   wrapped user key together with the key unwrap functions:
  </para>

<programlisting>
 =# INSERT INTO tbl
        VALUES (pgp_sym_encrypt('secret data',
                                 pg_unwrap('\xb2c89f76f04f95d029f179e0fc3df4ed7254127b5562a9e27d42d1cd037c942dea65ce7c0750c520fa4f4e90481c9eb7e1e42a068248c262c1a6f25c6eab64303b1154ccc9a14361223641aab4a7aabe')));
 INSERT 1

 =# SELECT * FROM tbl;
                                                                             col
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 \xc30d04070302a199ee38bea0320b75d23c01577bb3ffb315d67eecbeca3e40e869cea65efbf0b470f805549af905f94d94c447fbfb8113f585fc86b30c0bd784b10c9857322dc00d556aa8de14
(1 row)

 =# SELECT pgp_sym_decrypt(col,
                           pg_unwrap('\xb2c89f76f04f95d029f179e0fc3df4ed7254127b5562a9e27d42d1cd037c942dea65ce7c0750c520fa4f4e90481c9eb7e1e42a068248c262c1a6f25c6eab64303b1154ccc9a14361223641aab4a7aabe')) as col
    FROM tbl;
     col
--------------
 secret data
(1 row)
</programlisting>

  <para>
   The data <literal>'secret data'</literal> is practically encrypted by the
   user secret <literal>'my secret passward'</literal> but using wrap and
   unwrap functions user don't need to know the actual user secret during
   operation.
  </para>
 </sect1>

 <sect1 id="key-management-rotation">
  <title>Key Rotation Process</title>

  <para>
   Encryption keys in general are not interminable, the longer the same key is in use,
   the chance  of it being breached increases. Performing key rotation on a regular basis
   help meet standardized security practices such as <ulink url="https://www.pcisecuritystandards.org/">
   PCI-DSS</ulink> and it is a good practice in security to limit the number of encrypted
   bytes available for a specific key version. The key lifetimse are based on key length,
   key strength, algorithm and total number of bytes enciphered. The key management systems
   provides a efficient method to perform key rotation.
  </para>

  <para>
   Please be aware that the phrase <literal>"key rotation"</literal> here only refers to the
   rotation of <acronym>KEK</acronym>. The cryptographic keys managed by encryption key
   management system are not rotated; they will in fact be the same before and after a
   <literal>"key rotation."</literal> This can be justified because the actual keys are never stored anywhere
   physically, presented to user or captured in logging. What is being rotated here is the
   <acronym>KEK</acronym> who is responsible for encapsulating and restoring cryptographic
   keys.
  </para>

  <para>
   Since <acronym>KEK</acronym> is derived from a cluster passphrase, the <literal>"key rotation"
   </literal> ultimately refers to the rotation of cluster passphrase and deriving a new
   <acronym>KEK</acronym> from the new cluster passphrase. The new <acronym>KEK</acronym> can
   then be used to encapsulate all encryptions keys and store the new results in
   <filename>pg_cryptokeys</filename> directory.
  </para>

  <para>
   To complete the cluster passphrase rotation, user needs to follow the steps below:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Ensure the <productname>PostgreSQL</productname> server is running correctly with KMS enabled.
     Passphrase rotation cannot be completed with the server shut down.
    </para>
   </listitem>
   <listitem>
    <para>
     Update <xref linkend="guc-cluster-passphrase-command"/> parameter and load such that the new
     command will return a new cluster passphrase.
    </para>
   </listitem>
   <listitem>
    <para>
     In a session, execute <function>pg_rotate_cluster_passphrase()</function> SQL
     function to initiate the rotation. The function returns true upon successful key rotation and false if
     otherwise.
    </para>
	<programlisting>
=# SELECT pg_rotate_cluster_passphrase();
pg_rotate_cluster_passphrase
------------------------------
 t
(1 row)
    </programlisting>
   </listitem>
  </itemizedlist>
  <para>
   Upon successful cluster passphrase rotation, all managed cryptographic keys will be re-encapsulated by the
   new <acronym>KEK</acronym> derived from the new cluster passphrase. The new encapsulated  keys will be
   stored in <filename>pg_cryptokeys</filename> directory.  Please note that the cryptographic keys are
   the same as before; the rotation process only changes the <acronym>KEK</acronym> that is used to encapsulate
   and verify the actual cryptographic keys. This way, there is no need to decrypt all the encrypted data with
   the old keys and re-encrypt them with the new.
  </para>
  <para>
   In case of a crash during the cluster passphrase rotation process, the key management system is able to recover
   to the previous sets of cryptographic keys the next time server starts up. This is possible because the
   key rotation and encapsulation process are done on a separate tempory key directory called <filename>
   pg_cryptokeys_tmp</filename> and it will replace <filename>pg_cryptokeys</filename> and be deleted only when
   everything is successfully finished. If the server starts with pg_cryptokeys_tmp folder present, it would
   indicate that previous attempt of cluster passphrase rotation was not completed. In this case, the server
   will discard <filename>pg_cryptokeys_tmp</filename> folder and load the keys in
   <filename>pg_cryptokeys</filename> as usual.
  </para>
 </sect1>
</chapter>

<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">

  <title>Logical Replication</title>
  <para>
    Logical replication is a method of replicating data objects and their
    changes, based upon their primary keys (or replication identity). We
    use the term logical in contrast to physical replication which
    uses exact block addresses and byte-by-byte replication.
    PostgreSQL supports both mechanisms concurrently, see
    <xref linkend="high-availability">. Logical replication allows
    fine-grained control over both data replication and security.
  </para>
  <para>
    Logical replication uses a <firstterm>publish</> and
    <firstterm>subscribe</> model with one or
    more <firstterm>subscribers</> subscribing to one or more
    <firstterm>publications</> on a <firstterm>publisher</> node.
    Subscribers pull data from the publications they
    subscribe to and may subsequently re-publish data to allow
    cascading replication or more complex configurations.
  </para>
  <para>
    Logical replication typically starts with a snapshot of the data on
    the publisher database. Once that is done, the changes on the publisher
    are sent to the subscriber as they occur in real-time. The subscriber
    applies the data in the same order as the publisher so that
    transactional consistency is guaranteed for publications within a
    single subscription. This method of data replication is sometimes
    referred to as transactional replication.
  </para>
  <para>
    The typical use-cases for logical replication are:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Sending incremental changes in a single database or a subset of
        a database to Subscribers as they occur.
      </para>
    </listitem>
    <listitem>
      <para>
        Firing triggers for individual changes as they are incoming to
        subscriber.
      </para>
    </listitem>
    <listitem>
      <para>
        Consolidating multiple databases into a single one (for example
        for analytical purposes).
      </para>
    </listitem>
    <listitem>
      <para>
        Replicating between different major versions of PostgreSQL
      </para>
    </listitem>
    <listitem>
      <para>
        Giving access to replicated data to different groups of
        users.
      </para>
    </listitem>
    <listitem>
      <para>
        Sharing a subset of the database between multiple databases.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    The subscriber database behaves in the same way as any other
    PostgreSQL instance and can be used as a publisher for other
    databases by defining its own publications. When the subscriber is
    treated as read-only by application, there will be no conflicts from
    a single subscription. On the other hand if there are other writes
    done either by application or other subscribers to the same set of
    tables conflicts can arise.
  </para>

<sect1 id="logical-replication-publication">
  <title>Publication</title>
  <para>
    A <firstterm>publication</> object can be defined on any physical
    replication master. The node where a publication is defined is referred
    to as <firstterm>publisher</>. Only superusers or members of the
    <literal>REPLICATION</> role can define a publication. A publication is
    a set of changes generated from a group of tables, and might also be
    described as a <firstterm>change set</> or <firstterm>replication set</>.
    Each publication exists in only one database.
  </para>
  <para>
    Publications are different from table schema and do not affect
    how the table is accessed. Each table can be added to multiple
    publications if needed.  Publications may currently only contain
    tables. Objects must be added explicitly, except when a publication
    is created for <literal>ALL TABLES</>. There is no default name for
    a publication which specifies all tables.
  </para>
  <para>
    Publications can choose to limit the changes they produce to show
    any combination of <command>INSERT</>, <command>UPDATE</>,
    <command>DELETE</> and <command>TRUNCATE</> in a similar
    way to the way triggers are fired by particular event types. Only
    tables with a <literal>REPLICA IDENTITY</> index can be added to a
    publication which replicates <command>UPDATE</> and <command>DELETE</>
    operation.
  </para>
  <para>
    The definition of a publication object will be included within
    pg_dump.
  </para>
  <para>
    Every publication can have multiple subscribers.
  </para>
  <para>
    Publication is created using the <xref linkend="sql-createpublication">
    command and may be later altered or dropped using corresponding commands.
  </para>
  <para>
    The individual tables can be added and removed dynamically using
    <xref linkend="sql-alterpublication">. Both the <literal>ADD TABLE</>
    and <literal>DROP TABLE</> operations are transactional so the table
    will start or stop replicating at the correct snapshot once the
    transaction has committed.
  </para>
</sect1>
<sect1 id="logical-replication-subscription">
  <title>Subscription</title>
  <para>
    A <firstterm>subscription</> is the downstream side of logical
    replication. The node where subscription is defined is referred to as
    the <firstterm>subscriber</>. Subscription defines the connection to
    another database and set of publications (one or more) to which it
    wants to be subscribed.
  </para>
  <para>
    The subscriber database behaves in the same way as any other
    PostgreSQL instance and can be used as a publisher for other
    databases by defining its own publications.
  </para>
  <para>
    A subscriber may have multiple subscriptions if desired. It is
    possible to define multiple subscriptions between a single
    publisher-subscriber pair, in which case extra care must be taken
    to ensure that the subscribed publication objects don't overlap.
  </para>
  <para>
    Each subscription will receive changes via one replication slot (see
    <xref linkend="streaming-replication-slots">). Additional temporary
    replication slots may be required for the initial data synchronizations
    of pre-existing table data.
  </para>
  <para>
    Subscriptions are not dumped by pg_dump by default but can be
    requested using the --subscriptions parameter.
  </para>
  <para>
    The subscription is added using <xref linkend="sql-createsubscription">
    and can be stopped/resumed at any time using the
    <xref linkend="sql-altersubscription"> command or removed using
    <xref linkend="sql-dropsubscription">.
  </para>
  <para>
    When subscription is dropped and recreated, the synchronization
    information is lost. This means that the data has to be
    resynchronized afterwards.
  </para>
</sect1>
<sect1 id="logical-replication-conflicts">
  <title>Conflicts</title>
  <para>
    The logical replication behaves similarly to normal <literal>DML</>
    operations in that the data will be updated even if it was changed
    locally on the subscriber node. If the incoming data
    violates any constraints the replication will stop. This is referred
    to as a <firstterm>conflict</>. When replicating <command>UPDATE</>
    or <command>DELETE</> operations, missing data will not produce a
    conflict and such operations will simply be skipped.
  </para>
  <para>
    A conflict will produce an error and will stop the replication; it
    must be resolved manually by the user.
  </para>
  <para>
    The resolution can be done either by changing data on the subscriber
    so that it does not conflict with incoming change or by skipping the
    transaction that conflicts with the existing data. The transaction
    can be skipped by calling the
    <link linkend="pg-replication-origin-advance">
    <function>pg_replication_origin_advance()</function></link> function
    with a <literal>node_name</> corresponding to the subscription name. The
    current position of origins can be seen in the
    <link linkend="view-pg-replication-origin-status">
    <structname>pg_replication_origin_status</structname></link> system view.
  </para>
</sect1>
<sect1 id="logical-replication-architecture">
  <title>Architecture</title>
  <para>
    Logical replication starts by copying a snapshot of the data on
    the publisher database. Once that is done, changes on the publisher
    are sent to the subscriber as they occur in real-time. The subscriber
    applies data in the order in which commits were made on the
    publisher so that transactional consistency is guaranteed for the
    publications within any single Subscription.
  </para>
  <para>
    Logical replication is built with an architecture similar to
    physical streaming replication
    (see <xref linkend="streaming-replication">). It is implemented by
    WalSender and the Apply processes. The WalSender starts logical
    decoding (described in <xref linkend="logicaldecoding">) of the WAL and
    loads the standard logical decoding plugin (pgoutput). The plugin
    transforms the changes read from WAL to the logical replication protocol
    (see <xref linkend="protocol-logical-replication">) and filters the data
    according to publication specification. The data are then continuously
    transferred using the streaming replication protocol to the Apply worker
    which maps them to the local tables and applies the individual changes as
    they are received in exact transactional order.
  </para>
  <para>
    The Apply process on the subscriber database always runs with
    session_replication_role set to replica, which produces the usual effects
    on triggers and constraints.
  </para>
  <sect2 id="logical-replication-snapshot">
    <title>Initial snapshot</title>
    <para>
      The initial data in existing subscribed tables are snapshotted and
      copied in a parallel instance of a special kind of Apply process.
      This process will create its own temporary replication slot and
      copy the existing data. Once existing data is copied, the worker
      enters synchronization mode which ensures that the table is brought
      up to synchronized state with the main Apply process by streaming
      any changes which happened during the initial data copy using standard
      logical replication. Once the synchronization is done, the control
      of the replication of the table is given back to the main Apply
      process where the replication continues as normal.
    </para>
  </sect2>
</sect1>
<sect1 id="logical-replication-monitoring">
  <title>Monitoring</title>
  <para>
    Because logical replication is based on similar architecture as
    <link linkend="streaming-replication">physical streaming
    replication</link> the monitoring on publication is very similar to
    monitoring of physical replication master (see
    <xref linkend="streaming-replication-monitoring">).
  </para>
  <para>
    The monitoring information about subscription is visible in
    <link linkend="pg-stat-subscription"><literal>pg_stat_subscription</></link>.
    This view contains one row for every subscription worker. Subscription
    can have zero or more active subscription workers depending on its state.
  </para>
  <para>
    Normally there is a single Apply process running for the enabled
    subscription. The disabled subscription of crashed subscription will
    have zero rows in this view. If the initial data synchronization of
    any table is in progress there will be additional worker(s) for the
    table(s) being synchronized.
  </para>
</sect1>
<sect1 id="logical-replication-security">
  <title>Security</title>
  <para>
    Replication connection can occur in the same way as physical streaming
    replication. It requires access to be specifically given using
    pg_hba.conf. The role used for the replication must have
    <literal>REPLICATION</literal> privilege <command>GRANT</command>ED.
    This gives a role access to both logical and physical replication.
  </para>
  <para>
    To create a publication the user must have the REPLICATION role, or be
    a superuser.
  </para>
  <para>
    To create a subscription the user must be a superuser.
  </para>
  <para>
    The subscription apply process will run in the local database
    with the privileges of a superuser.
  </para>
  <para>
    In particular, note that privileges are not re-checked as each change
    record is read from the publisher, nor are they re-checked for each change
    when applied. Security is checked once at startup.
  </para>
</sect1>
<sect1 id="logical-replication-gucs">
  <title>Logical replication related configuration parameters</title>
  <para>
    The Logical Replication requires several configuration options to be
    set.
  </para>
  <para>
    On the publisher side the <varname>wal_level</> must be set to
    <literal>logical</>, and <varname>max_replication_slots</> has to be set to
    at least the number of Subscriptions expected to connect with some reserve
    for table synchronization as well. And <varname>max_wal_senders</>
    should be set to at least the same as <varname>max_replication_slots</> plus
    the number of physical replicas that are connected at the same time.
  </para>
  <para>
    The Subscriber also requires the <varname>max_replication_slots</> to
    be set. In this case it should be set to at least the number of
    Subscriptions that will be added to the Subscriber. The
    <varname>max_logical_replication_workers</> has to be set to at least
    the number of Subscriptions again with some reserve for the table
    synchronization. Additionally the <varname>max_worker_processes</> may
    need to be adjusted to accommodate for replication workers, at least
    (<varname>max_logical_replication_workers</> + <literal>1</>). Please
    note that some extensions and parallel queries also take worker slots
    from <varname>max_worker_processes</>.
  </para>
</sect1>
<sect1 id="logical-replication-quick-setup">
  <title>Quick setup</title>
  <para>
    First set the configuration options in the postgresql.conf:
<programlisting>
wal_level = logical
max_worker_processes = 10 # one per subscription + one per instance needed on subscriber
max_logical_replication_workers = 10 # one per subscription + one per instance needed on subscriber
max_replication_slots = 10 # one per subscription needed on both publisher and subscriber
max_wal_senders = 10 # one per subscription needed on publisher
</programlisting>
  </para>
  <para>
    The pg_hba.conf needs to be adjusted to allow replication (the
    values here depend on your actual network configuration and user you
    want to use for connecting):
<programlisting>
host    replication     repuser     0.0.0.0/0       md5
</programlisting>
  </para>
  <para>
    Then on the publisher database:
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>
  <para>
    And on the Subscriber database:
<programlisting>
CREATE SUBSCRIPTION mysub WITH CONNECTION <quote>dbname=foo host=bar user=repuser</quote> PUBLICATION mypub;
</programlisting>
  </para>
  <para>
    The above will start the replication process which synchronizes the
    initial table contents of <literal>users</literal> and
    <literal>departments</literal> tables and then starts replicating
    incremental changes to those tables.
  </para>
</sect1>
</chapter>
